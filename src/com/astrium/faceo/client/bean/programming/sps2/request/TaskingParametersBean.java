package com.astrium.faceo.client.bean.programming.sps2.request;/* * @(#)TaskingParametersBean.java	 1.0  28/05/2010 * * * PROJET       : SITE FACEO * * LANGUAGE     : Java * * DESCRIPTION  : The TaskingParametersBean class is used to specify the parameters * for GetFeasibility or Submit Operation. * * CREATION : * --------------------------------------------------------------------- * | Date       | Version | Description                                | * --------------------------------------------------------------------- * | 28/05/2010 |    1.0  |                                            | * --------------------------------------------------------------------- * * MODIFICATION : * --------------------------------------------------------------------- * | Date       | Version | Description                                | * --------------------------------------------------------------------- * |            |         |                                            | * --------------------------------------------------------------------- * *//* * sample of Acquisition type for GetFeasibility Request *  *   <eo:AcquisitionType> *       <eo:MonoscopicAcquisition> *            <eo:CoverageType>MULTIPASS</eo:CoverageType> *            <eo:IncidenceAngle> *               <eo:Azimuth> *                  <eo:min>-180.0</eo:min> *                  <eo:max>180.0</eo:max> *               </eo:Azimuth> *               <eo:Elevation> *                  <eo:min>0.0</eo:min> *                  <eo:max>15.0</eo:max> *               </eo:Elevation> *            </eo:IncidenceAngle> *            <eo:AcquisitionParametersOPT> *               <eo:GroundResolution> *                  <eo:min>2.5</eo:min> *                  <eo:max>10.0</eo:max> *               </eo:GroundResolution> *               <eo:InstrumentMode>PANCHROMATIC</eo:InstrumentMode> *               <eo:FusionAccepted>false</eo:FusionAccepted> *            </eo:AcquisitionParametersOPT> *       </eo:MonoscopicAcquisition> *   </eo:AcquisitionType> */// importimport java.io.Serializable;import com.astrium.faceo.client.bean.programming.sps2.SensorBean;/** * <B>SITE FACEO</B> <BR> *  * <P> * Acquisition Type informations : * The TaskingParametersBean class is used to specify the parameters * for GetFeasibility or Submit Operation. * </P> * </P> <BR> *  * @author  GR * @version 1.0, le 28/05/2010 */public class TaskingParametersBean implements Serializable {	/**	 * 	 */	private static final long serialVersionUID = -7085994312637357210L;	// ------------------- Sensor decription -------------------	/** sensor description */	private SensorBean sensor = new SensorBean();	// ------------------- QOS Parameters -------------------		/** Quality Of Service	 *	 * true if this parameter is available, false else 	 */	private boolean qualityOfService = false;	/** Priority Level	 *	 * STANDARD or HIGH = Level of priority previously agreed upon with provider	 * 	 * true if this parameter is available, false else 	 */	private boolean priorityLevel = false;	/** priority Level values :	 */	private String[] priorityLevelValues = null;	/** priority Level default value :	 */	private String priorityLevelDefaultValue = "";	// ------------------- Acquisition Parameters -------------------	/**	 * Acquisition Type informations :	 * The AcquisitionType class is used to specify if the acquisition is monoscopic or	 * stereoscopic, as well as contain specific acquisition parameters.	 * 	 * true if this parameter is available, false else 	 */	private boolean acquisitionType = false;	/**	 * Monoscopic Acquisition :	 * 	 */	private boolean acquisitionMonoscopic = false;	/**	 * Stereoscopic Acquisition :	 * 	 */	private boolean acquisitionStereoscopic = false;	/**	 * Acquisition Type informations : for OPT (Optical) sensor	 * 	 * true if this parameter is available, false else 	 */	private boolean acquisitionOpticalType = false;	/**	 * Acquisition Type informations : for SAR (Radar) sensor	 * 	 * true if this parameter is available, false else 	 */	private boolean acquisitionRadarType = false;	/** polarization Mode :	 * 	 * Receive/Transmit polarization mode of a SAR instrument	 *	 * true if this parameter is available, false else 	 */	private boolean polarizationMode = false;	/** polarization Mode values :	 */	private String[] polarizationModeValues = null;	/** polarization Mode default value :	 */	private String polarizationModeDefaultValue = "";	/** min Luminosity (%) (OPTICAL) :	 * 	 * Minimum luminosity acceptable for acquired imagery.	 *	 * true if this parameter is available, false else 	 */	private boolean minLuminosity = false;	/** min Luminosity (%) (OPTICAL) :	 * 	 * Minimum luminosity acceptable for acquired imagery.	 */	private int minLuminosityValue = 0;	// ---------------- OPT and SAR Acquisition Parameters ---------------------	/** fusion Accepted :	 * Specifies if imagery obtained by fusing several	 * images acquired separately and co-registered is acceptable.	 */	private boolean fusionAccepted = false;	/** instrument Mode :	 * A categorical value used to specify a particular instrument configuration. 	 * All possible modes should be defined by a code space. 	 * A default code space is defined by this specification	 * ‘urn:ogc:def:dictionary:CEOS:eop:SpectralModes’	 * and should be used when applicable	 */	private boolean instrumentMode = false;	/** instrument Mode values :	 */	private String[] instrumentModeValues = null;	/** instrument Mode default value :	 */	private String instrumentModeDefaultValue = "";	/** Polarization Mode :	 * Receive/Transmit polarization mode of a SAR instrument. 	 * A default codespace is defined by this specification	 * ‘urn:ogc:def:dictionary:CEOS:sar:PolarizationModes’	 * and should be used when applicable.	 */	/** ground Resolution Range :	 * Distance between two contiguous pixels of remote	 * sensed imagery when projected on the earth. The	 * type of this parameter is a QuantityRange,	 * allowing the user to specify a range of acceptable	 * ground resolutions.	 */	/** Ground Resolution 	 * 	 * true if this parameter is available, false else 	 */	private boolean groundResolution = false;	/** Ground Resolution min */	private double groundResolutionMin = 0;	/** Ground Resolution max */	private double groundResolutionMax = 0;	/** 	 * coverage type :	 * 	 * Specifies if the imagery should be acquired in one or multiple passes.	 * SINGLE_SWATH: The region of interest should be covered by a single segment.	 * MONOPASS: The region of interest must be covered by one or more	 * segments acquired from the same orbit (some agile satellites can cover	 * large zones even when satisfying this constraint).	 * MULTIPASS: The region of interest can be covered by using images	 * extracted from several segments acquired at different dates provided	 * that they are all acquired within the requested time period	 * 	 * true if this parameter is available, false else 	 */	private boolean coverageType = false;	/** coverage Type values :	 */	private String[] coverageTypeValues = null;	/** coverage Type default value :	 */	private String coverageTypeDefaultValue = "";	/**	 * BH Ratio :	 * Ratio between base and height of the triangle constructed by	 * viewing directions of the two acquisitions in a stereoscopic	 * couple, and the local horizontal plane.	 * 	 * true if this parameter is available, false else 	 */	private boolean bHRatio = false;	/**	 * Max Couple Delay : (days)	 * Maximum time delay between two acquisitions of a stereoscopic couple.	 * 	 * true if this parameter is available, false else 	 */	private boolean maxCoupleDelay = false;	/** 	 * incidence angle range : azimuth range and elevation range	 * Specification of allowed acquisition angles in terms of angles expressed relative to a	 * frame of reference attached to the location of the acquisition (i.e. on the ground).		 */	/**	 * Azimuth Range :	 * Range of acceptable azimuth incidence angles. 	 * The azimuth angle is the angle that the look vector (projected vertically on the earth surface) 	 * makes with the north direction. It thus indicates from which geographic direction (i.e. North, East, West,	 * South) the region of interest should be imaged.	 */	/** azimuth incidence parameter	 * true if this parameter is available, false else 	 */	private boolean azimuth = false;	/** azimuth incidence min (deg) */	private int azimuthIncidenceMin = 0;	/** azimuth incidence max (deg) */	private int azimuthIncidenceMax = 0;	/**	 * Elevation incidence parameter :	 * 	 * Range of acceptable elevation incidence angles. 	 * The elevation angle is the angle that the look vector makes	 * with the local vertical. It thus indicates how vertically the region should be imaged.	 * This is the traditional meaning of incidence angle	 */	/** elevation incidence parameter 	 * true if this parameter is available, false else 	 */	private boolean elevation = false;	/** elevation incidence min (deg) */	private int elevationIncidenceMin = 0;	/** elevation incidence max (deg) */	private int elevationIncidenceMax = 0;	/**	 * Pointing Angle Range : Along Track Range and across Track range	 * Specification of allowed acquisition angles in terms of angles expressed in the satellite	 * reference frame and relative to the nadir direction.	 */	/** alongTrack parameter	 * true if this parameter is available, false else 	 */	private boolean alongTrack = false;	/**	 * AlongTrackRange :	 * Range of acceptable pointing angles in the along track direction (i.e. the angle	 * between the nadir direction and the look vector, measured around the axis	 * of the satellite reference frame that is orthogonal to the orbit plane)	 */	/** Along Track Range min (deg) */	private int alongTrackMin = 0;	/** Along Track Range max (deg) */	private int alongTrackMax = 0;	/** acrossTrack parameter	 * true if this parameter is available, false else 	 */	private boolean acrossTrack = false;	/**	 * AcrosTrackRange :	 * Range of acceptable pointing angles in the across track direction (i.e. the	 * angle between the nadir direction and the look vector, measured around the	 * axis of the satellite reference frame with a direction tangent to the satellite	 * trajectory)	 */	/** Across Track Range min (deg) */	private int acrossTrackMin = 0;	/** Across Track Range max (deg) */	private int acrossTrackMax = 0;	// ------------------- Validation Parameters -------------------		// ------------------- Validation SAR Parameters -------------------		/** validation parameters for SAR sensor.	 * 	 * true if this parameter is available, false else 	 */	private boolean validationParametersSAR = false;		/** max Noise Level : (from 0 to 100 : %) 	 * 	 * true if this parameter is available, false else 	 */	private boolean maxNoiseLevel = false;	/** max Noise Level : (from 0 to 100 : %) 	 * 	 * Max Noise Level acceptable for acquired imagery.	 */	private int maxNoiseLevelValue = 0;		/** max Ambiguity Level : (from 0 to 100 : %) 	 * 	 * true if this parameter is available, false else 	 */	private boolean maxAmbiguityLevel = false;	/** max Ambiguity Level : (from 0 to 100 : %) 	 * 	 * Max Ambiguity Level acceptable for acquired imagery.	 */	private int maxAmbiguityLevelValue = 0;	// ------------------- Validation Optical Parameters -------------------		/** validation parameters for Optical sensor.	 * 	 * true if this parameter is available, false else 	 */	private boolean validationParametersOPT = false;		/** max Cloud Coverage : (from 0 to 100 : %) 	 * Maximum acceptable cloud cover. The	 * cloud cover is the portion of the image	 * area covered by clouds.	 * 	 * true if this parameter is available, false else 	 */	private boolean maxCloudCoverage = false;	/** max Cloud Coverage : (from 0 to 100 : %) 	 * 	 * Max Cloud Coverage acceptable for acquired imagery.	 */	private int maxCloudCoverageValue = 0;	/** max Snow Coverage : (from 0 to 100 : %) 	 *  Maximum acceptable snow coverage.	 *	The snow cover is the portion of the	 *	image area covered by snow.	 * 	 * true if this parameter is available, false else 	 */	private boolean maxSnowCoverage = false;		/** max Snow Coverage : (from 0 to 100 : %) 	 *  	 * Max Snow Coverage acceptable for acquired imagery.	 */	private int maxSnowCoverageValue  = 0;	/** haze Accepted : specifies if haze (brouillard) is acceptable.	 * 	 * true if this parameter is available, false else 	 */	private boolean hazeAccepted = false;	/** Sand Wind Accepted : Specifies if sand wind is acceptable. 	 * 	 * true if this parameter is available, false else 	 */	private boolean sandWindAccepted = false;	/**	 * debut des methodes	 	 * 	 * Constructeur par defaut : vide	 */	public TaskingParametersBean() {	}	/** getters */		/** 	 * getter on sensor	 * 	 * @return SensorBean : sensor description	*/	public SensorBean getSensor() {		return this.sensor;	}	// ------------------- QOS Parameters -------------------		/** 	 * getter on qualityOfService parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getQualityOfService() {		return this.qualityOfService;	}	/** 	 * getter on priorityLevel parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getPriorityLevel() {		return this.priorityLevel;	}		/** 	 * getter on priority Level values	 * 	 * @return String[] : values for priority Level	 */	public String[] getPriorityLevelValues() {		return this.priorityLevelValues;	}	/** 	 * getter on priority Mode Level value	 * 	 * @return String : default value for priority Level	 */	public String getPriorityLevelDefaultValue() {		return (this.priorityLevelDefaultValue != null) ? this.priorityLevelDefaultValue : "";	}	// ------------------- Acquisition Parameters -------------------	/** 	 * getter on acquisitionType parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getAcquisitionType() {		return this.acquisitionType;	}	/** 	 * getter on acquisitionMonoscopic parameter	 * 	 * @return boolean : true Monoscopic acquisition, false else	 */	public boolean getAcquisitionMonoscopic() {		return this.acquisitionMonoscopic;	}	/**	 * Stereoscopic Acquisition :	 * 	 */	/** 	 * getter on acquisitionStereoscopic parameter	 * 	 * @return boolean : true Stereoscopic acquisition, false else	 */	public boolean getAcquisitionStereoscopic() {		return this.acquisitionStereoscopic;	}	/** 	 * getter on acquisitionOpticalType parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getAcquisitionOpticalType() {		return this.acquisitionOpticalType;	}	/** 	 * getter on acquisitionRadarType parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getAcquisitionRadarType() {		return this.acquisitionRadarType;	}	/** 	 * getter on polarizationMode parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getPolarizationMode() {		return this.polarizationMode;	}	/** 	 * getter on polarization Mode values	 * 	 * @return String[] : values for polarization mode	 */	public String[] getPolarizationModeValues() {		return this.polarizationModeValues;	}	/** 	 * getter on polarization Mode default value	 * 	 * @return String : default value for polarization mode	 */	public String getPolarizationModeDefaultValue() {		return (this.polarizationModeDefaultValue != null) ? this.polarizationModeDefaultValue : "";	}	/** 	 * getter on minLuminosity parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getMinLuminosity() {		return this.minLuminosity;	}	/** 	 * getter on minLuminosity parameter	 * 	 * @return int : min Luminosity value	 */	public int getMinLuminosityValue() {		return this.minLuminosityValue;	}	/** 	 * getter on fusionAccepted	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getFusionAccepted() {		return this.fusionAccepted;	}	/** 	 * getter on instrumentMode	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getInstrumentMode() {		return this.instrumentMode;	}	/** 	 * getter on instrumentModeValues	 * 	 * @return String[] : values for instrument mode	 */	public String[] getInstrumentModeValues() {		return this.instrumentModeValues;	}	/** 	 * getter on instrumentModeDefaultValue	 * 	 * @return String[] : default value for instrument mode	 */	public String getInstrumentModeDefaultValue() {		return (this.instrumentModeDefaultValue != null) ? this.instrumentModeDefaultValue : "";	}	/** 	 * getter on groundResolution	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getGroundResolution() {		return this.groundResolution;	}	/** 	 * getter on groundResolutionMin	 * 	 * @return double : ground Resolution Min	 */	public double getGroundResolutionMin() {		return this.groundResolutionMin;	}	/** 	 * getter on groundResolutionMax	 * 	 * @return double : ground Resolution Max	 */	public double getGroundResolutionMax() {		return this.groundResolutionMax;	}	/** 	 * getter on coverageType parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getCoverageType() {		return this.coverageType;	}	/** 	 * getter on coverage type values	 * 	 * @return String[] : values for coverage type	 */	public String[] getCoverageTypeValues() {		return this.coverageTypeValues;	}	/** 	 * getter on coverage Type default value	 * 	 * @return String : default value for coverage type	 */	public String getCoverageTypeDefaultValue() {		return (this.coverageTypeDefaultValue != null) ? this.coverageTypeDefaultValue : "";	}	/** 	 * getter on maxCoupleDelay parameter	 * 	 * @return boolean :  true if this parameter is available, false else	 */	public boolean getBHRatio() {		return this.bHRatio;	}	/** 	 * getter on maxCoupleDelay parameter	 * 	 * @return boolean :  true if this parameter is available, false else	 */	public boolean getMaxCoupleDelay() {		return this.maxCoupleDelay;	}	/** 	 * getter on azimuth parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getAzimuth() {		return this.azimuth;	}	/** 	 * getter on azimuthIncidenceMin (deg)	 * 	 * @return int : azimuth Incidence Min	 */	public int getAzimuthIncidenceMin() {		return this.azimuthIncidenceMin;	}	/** 	 * getter on azimuthIncidenceMax (deg)	 * 	 * @return int : azimuth Incidence Max	 */	public int getAzimuthIncidenceMax() {		return this.azimuthIncidenceMax;	}	/** 	 * getter on elevation parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getElevation() {		return this.elevation;	}	/** 	 * getter on elevationIncidenceMin (deg)	 * 	 * @return int : elevation Incidence Min	 */	public int getElevationIncidenceMin() {		return this.elevationIncidenceMin;	}	/** 	 * getter on elevationIncidenceMax (deg)	 * 	 * @return int : elevation Incidence Max	 */	public int getElevationIncidenceMax() {		return this.elevationIncidenceMax;	}	/** 	 * getter on alongTrack parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getAlongTrack() {		return this.alongTrack;	}	/**  acquisition angle : Azimuth Range ane Elevation Range */	/** 	 * getter on alongTrackMin (deg)	 * 	 * @return int : along Track Min	 */	public int getAlongTrackMin() {		return this.alongTrackMin;	}	/** 	 * getter on alongTrackMax (deg)	 * 	 * @return int : along Track Max	 */	public int getAlongTrackMax() {		return this.alongTrackMax;	}	/** 	 * getter on acrossTrack parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getAcrossTrack() {		return this.acrossTrack;	}	/** 	 * getter on acrossTrackMin (deg)	 * 	 * @return int : across Track Min	 */	public int getAcrossTrackMin() {		return this.acrossTrackMin;	}	/** 	 * getter on acrossTrackMax (deg)	 * 	 * @return int : across Track Max	 */	public int getAcrossTrackMax() {		return this.acrossTrackMax;	}		// ------------------- Validation Parameters -------------------		/** 	 * getter on validationParametersSAR parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getValidationParametersSAR() {		return this.validationParametersSAR;	}	/** 	 * getter on maxNoiseLevel parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getMaxNoiseLevel() {		return this.maxNoiseLevel;	}		/** 	 * getter on maxNoiseLevelValue parameter	 * 	 * @return int : max Noise Level value	 */	public int getMaxNoiseLevelValue() {		return this.maxNoiseLevelValue;	}		/** 	 * getter on maxAmbiguityLevel parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getMaxAmbiguityLevel() {		return this.maxAmbiguityLevel;	}		/** 	 * getter on maxAmbiguityLevelValue parameter	 * 	 * @return int : max Ambiguity Level value	 */	public int getMaxAmbiguityLevelValue() {		return this.maxAmbiguityLevelValue;	}	/** 	 * getter on validationParametersOPT parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getValidationParametersOPT() {		return this.validationParametersOPT;	}	/** 	 * getter on maxCloudCoverage parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getMaxCloudCoverage() {		return this.maxCloudCoverage;	}		/** 	 * getter on maxCloudCoverage parameter	 * 	 * @return int : max Cloud Coverage value	 */	public int getMaxCloudCoverageValue() {		return this.maxCloudCoverageValue;	}	/** 	 * getter on maxSnowCoverage parameter	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getMaxSnowCoverage() {		return this.maxSnowCoverage;	}		/** 	 * getter on maxSnowCoverage parameter	 * 	 * @return int : max Snow Coverage value	 */	public int getMaxSnowCoverageValue() {		return this.maxSnowCoverageValue;	}	/** 	 * getter on hazeAccepted : specifies if haze (brouillard) is acceptable	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getHazeAccepted() {		return this.hazeAccepted;	}	/** 	 * getter on sandWindAccepted : specifies if haze (brouillard) is acceptable	 * 	 * @return boolean : true if this parameter is available, false else	 */	public boolean getSandWindAccepted() {		return this.sandWindAccepted;	}	/** setters */		/** 	 * setter on sensor	 * 	 * @param _sensor (SensorBean) : sensor description	*/	public void setSensor(SensorBean _sensor) {		this.sensor = _sensor;	}	// ------------------- QOS Parameters -------------------	/** 	 * setter on qualityOfService	 * 	 * @param _qualityOfService (boolean) : true if this parameter is available, false else	 */	public void setQualityOfService(boolean _qualityOfService) {		this.qualityOfService = _qualityOfService;	}		/** 	 * setter on priorityLevel	 * 	 * @param _priorityLevel (boolean) : true if this parameter is available, false else	 */	public void setPriorityLevel(boolean _priorityLevel) {		this.priorityLevel = _priorityLevel;	}		/** 	 * setter on priorityLevelValues	 * 	 * @param _priorityLevelValues (String[]) : values for priority Level	 */	public void setPriorityLevelValues(String[] _priorityLevelValues) {		this.priorityLevelValues = _priorityLevelValues;	}	/** 	 * setter on priorityLevelDefaultValue	 * 	 * @param _priorityLevelDefaultValue (String) : default value for priority Level	 */	public void setPriorityLevelDefaultValue(String _priorityLevelDefaultValue) {		this.priorityLevelDefaultValue = _priorityLevelDefaultValue;	}	// ------------------- Acquisition Parameters -------------------	/** 	 * setter on acquisitionType	 * 	 * @param _acquisitionType (boolean) : true if this parameter is available, false else	 */	public void setAcquisitionType(boolean _acquisitionType) {		this.acquisitionType = _acquisitionType;	}	/** 	 * setter on acquisitionMonoscopic	 * 	 * @param _acquisitionMonoscopic (boolean) : true if Monoscopic acquisition, false else	 */	public void setAcquisitionMonoscopic(boolean _acquisitionMonoscopic) {		this.acquisitionMonoscopic = _acquisitionMonoscopic;	}	/** 	 * setter on acquisitionStereoscopic	 * 	 * @param _acquisitionStereoscopic (boolean) : true if Stereoscopic acquisition, false else	 */	public void setAcquisitionStereoscopic(boolean _acquisitionStereoscopic) {		this.acquisitionStereoscopic = _acquisitionStereoscopic;	}	/** 	 * setter on acquisitionOpticalType	 * 	 * @param _acquisitionOpticalType (boolean) : true if this parameter is available, false else	 */	public void setAcquisitionOpticalType(boolean _acquisitionOpticalType) {		this.acquisitionOpticalType = _acquisitionOpticalType;	}	/** 	 * setter on acquisitionRadarType	 * 	 * @param _acquisitionRadarType (boolean) : true if this parameter is available, false else	 */	public void setAcquisitionRadarType(boolean _acquisitionRadarType) {		this.acquisitionRadarType = _acquisitionRadarType;	}	/** 	 * setter on polarizationMode	 * 	 * @param _polarizationMode (boolean) : true if this parameter is available, false else	 */	public void setPolarizationMode(boolean _polarizationMode) {		this.polarizationMode = _polarizationMode;	}	/** 	 * setter on polarizationModeValues	 * 	 * @param _polarizationModeValues (String[]) : values for polarization Mode	 */	public void setPolarizationModeValues(String[] _polarizationModeValues) {		this.polarizationModeValues = _polarizationModeValues;	}	/** 	 * setter on polarizationModeDefaultValue	 * 	 * @param _polarizationModeDefaultValue (String) : default value for polarization Mode	 */	public void setPolarizationModeDefaultValue(String _polarizationModeDefaultValue) {		this.polarizationModeDefaultValue = _polarizationModeDefaultValue;	}	/** 	 * setter on minLuminosity	 * 	 * @param _minLuminosity (boolean) : true if this parameter is available, false else	 */	public void setMinLuminosity(boolean _minLuminosity) {		this.minLuminosity = _minLuminosity;	}	/** 	 * setter on minLuminosityValue	 * 	 * @param _minLuminosityValue (int) : min Luminosity Value	 */	public void setMinLuminosityValue(int _minLuminosityValue) {		this.minLuminosityValue = _minLuminosityValue;	}	/** 	 * setter on fusionAccepted	 * 	 * @param _fusionAccepted (boolean) : true if this parameter is available, false else	 */	public void setFusionAccepted(boolean _fusionAccepted) {		this.fusionAccepted = _fusionAccepted;	}	/** 	 * setter on instrumentMode	 * 	 * @param _instrumentMode (boolean) : true if this parameter is available, false else	 */	public void setInstrumentMode(boolean _instrumentMode) {		this.instrumentMode = _instrumentMode;	}	/** 	 * setter on instrumentModeValues	 * 	 * @param _instrumentModeValues (String[]) : values for instrument Mode	 */	public void setInstrumentModeValues(String[] _instrumentModeValues) {		this.instrumentModeValues = _instrumentModeValues;	}	/** 	 * setter on instrumentModeDefaultValue	 * 	 * @param _instrumentModeDefaultValue (String) : default value for instrument Mode	 */	public void setInstrumentModeDefaultValue(String _instrumentModeDefaultValue) {		this.instrumentModeDefaultValue = _instrumentModeDefaultValue;	}	/** 	 * setter on groundResolution	 * 	 * @param _groundResolution (boolean) : true if this parameter is available, false else	 */	public void setGroundResolution(boolean _groundResolution) {		this.groundResolution = _groundResolution;	}	/** 	 * setter on groundResolutionMin	 * 	 * @param _groundResolutionMin (double): ground resolution min value	 */	public void setGroundResolutionMin(double _groundResolutionMin) {		this.groundResolutionMin = _groundResolutionMin;	}	/** 	 * setter on groundResolutionMax	 * 	 * @param _groundResolutionMax (double): ground resolution max value	 */	public void setGroundResolutionMax(double _groundResolutionMax) {		this.groundResolutionMax = _groundResolutionMax;	}	/** 	 * setter on coverageType	 * 	 * @param _coverageType (boolean) : true if this parameter is available, false else	 */	public void setCoverageType(boolean _coverageType) {		this.coverageType = _coverageType;	}	/** 	 * setter on coverageTypeValues	 * 	 * @param _coverageTypeValues (String[]) : values for coverage type	 */	public void setCoverageTypeValues(String[] _coverageTypeValues) {		this.coverageTypeValues = _coverageTypeValues;	}	/** 	 * setter on coverageTypeDefaultValue	 * 	 * @param _coverageTypeDefaultValue (String) : default value for coverage type	 */	public void setCoverageTypeDefaultValue(String _coverageTypeDefaultValue) {		this.coverageTypeDefaultValue = _coverageTypeDefaultValue;	}	/** 	 * setter on bHRatio	 * 	 * @param _bHRatio (boolean) : true if this parameter is available, false else	 */	public void setBHRatio(boolean _bHRatio) {		this.bHRatio = _bHRatio;	}	/** 	 * setter on maxCoupleDelay	 * 	 * @param _maxCoupleDelay (boolean) : true if this parameter is available, false else	 */	public void setMaxCoupleDelay(boolean _maxCoupleDelay) {		this.maxCoupleDelay = _maxCoupleDelay;	}	/** 	 * setter on azimuth	 * 	 * @param _azimuth (boolean) : true if this parameter is available, false else	 */	public void setAzimuth(boolean _azimuth) {		this.azimuth = _azimuth;	}	/**  acquisition angle : Azimuth Range ane Elevation Range */	/** 	 * setter on azimuthIncidenceMin (deg)	 * 	 * @param _azimuthIncidenceMin (int): azimuth incidence min value	 */	public void setAzimuthIncidenceMin(int _azimuthIncidenceMin) {		this.azimuthIncidenceMin = _azimuthIncidenceMin;	}	/** 	 * setter on azimuthIncidenceMax (deg)	 * 	 * @param _azimuthIncidenceMax (int): azimuth incidence max value	 */	public void setAzimuthIncidenceMax(int _azimuthIncidenceMax) {		this.azimuthIncidenceMax = _azimuthIncidenceMax;	}	/** 	 * setter on elevation	 * 	 * @param _elevation (boolean) : true if this parameter is available, false else	 */	public void setElevation(boolean _elevation) {		this.elevation = _elevation;	}	/** 	 * setter on elevationIncidenceMin (deg)	 * 	 * @param _elevationIncidenceMin (int): elevation incidence min value	 */	public void setElevationIncidenceMin(int _elevationIncidenceMin) {		this.elevationIncidenceMin = _elevationIncidenceMin;	}	/** 	 * setter on elevationIncidenceMax (deg)	 * 	 * @param _elevationIncidenceMax (int): elevation incidence max value	 */	public void setElevationIncidenceMax(int _elevationIncidenceMax) {		this.elevationIncidenceMax = _elevationIncidenceMax;	}	/** 	 * setter on alongTrack	 * 	 * @param _alongTrack (boolean) : true if this parameter is available, false else	 */	public void setAlongTrack(boolean _alongTrack) {		this.alongTrack = _alongTrack;	}	/** 	 * setter on alongTrackMin (deg)	 * 	 * @param _alongTrackMin (int): along Track Min value	 */	public void setAlongTrackMin(int _alongTrackMin) {		this.alongTrackMin = _alongTrackMin;	}	/** 	 * setter on alongTrackMax (deg)	 * 	 * @param _alongTrackMax (int): along Track Max value	 */	public void setAlongTrackMax(int _alongTrackMax) {		this.alongTrackMax = _alongTrackMax;	}	/** 	 * setter on across	 * 	 * @param _acrossTrack (boolean) : true if this parameter is available, false else	 */	public void setAcrossTrack(boolean _acrossTrack) {		this.acrossTrack = _acrossTrack;	}	/** 	 * setter on acrossTrackMin (deg)	 * 	 * @param _acrossTrackMin (int): across Track Max value	 */	public void setAcrossTrackMin(int _acrossTrackMin) {		this.acrossTrackMin = _acrossTrackMin;	}	/** 	 * setter on acrossTrackMax (deg)	 * 	 * @param _acrossTrackMax (int): across Track Max value	 */	public void setAcrossTrackMax(int _acrossTrackMax) {		this.acrossTrackMax = _acrossTrackMax;	}	// ------------------- Validation Parameters -------------------	/** 	 * setter on validationParametersSAR	 * 	 * @param _validationParametersSAR (boolean): true if this parameter is available, false else	 */	public void setValidationParametersSAR(boolean _validationParametersSAR) {		this.validationParametersSAR = _validationParametersSAR;	}		/** 	 * setter on maxNoiseLevel	 * 	 * @param _maxNoiseLevel (boolean): true if this parameter is available, false else	 */	public void setMaxNoiseLevel(boolean _maxNoiseLevel) {		this.maxNoiseLevel = _maxNoiseLevel;	}		/** 	 * setter on maxNoiseLevelValue	 * 	 * @param _maxNoiseLevelValue (int) : max Noise Level Value	 */	public void setMaxNoiseLevelValue(int _maxNoiseLevelValue) {		this.maxNoiseLevelValue = _maxNoiseLevelValue;	}		/** 	 * setter on maxAmbiguityLevel	 * 	 * @param _maxAmbiguityLevel (boolean): true if this parameter is available, false else	 */	public void setMaxAmbiguityLevel(boolean _maxAmbiguityLevel) {		this.maxAmbiguityLevel = _maxAmbiguityLevel;	}		/** 	 * setter on maxAmbiguityLevelValue	 * 	 * @param _maxAmbiguityLevelValue (int) : max Ambiguity Level Value	 */	public void setMaxAmbiguityLevelValue(int _maxAmbiguityLevelValue) {		this.maxAmbiguityLevelValue = _maxAmbiguityLevelValue;	}	/** 	 * setter on validationParametersOPT	 * 	 * @param _validationParametersOPT (boolean): true if this parameter is available, false else	 */	public void setValidationParametersOPT(boolean _validationParametersOPT) {		this.validationParametersOPT = _validationParametersOPT;	}	/** 	 * setter on maxCloudCoverage	 * 	 * @param _maxCloudCoverage (boolean): true if this parameter is available, false else	 */	public void setMaxCloudCoverage(boolean _maxCloudCoverage) {		this.maxCloudCoverage = _maxCloudCoverage;	}		/** 	 * setter on maxCloudCoverage	 * 	 * @param _maxCloudCoverageValue (int) : max Cloud Coverage Value	 */	public void setMaxCloudCoverageValue(int _maxCloudCoverageValue) {		this.maxCloudCoverageValue = _maxCloudCoverageValue;	}	/** 	 * setter on maxSnowCoverage	 * 	 * @param _maxSnowCoverage (boolean): true if this parameter is available, false else	 */	public void setMaxSnowCoverage(boolean _maxSnowCoverage) {		this.maxSnowCoverage = _maxSnowCoverage;	}		/** 	 * setter on maxSnowCoverage	 * 	 * @param _maxSnowCoverageValue (int) : max Snow Coverage Value	 */	public void setMaxSnowCoverageValue(int _maxSnowCoverageValue) {		this.maxSnowCoverageValue = _maxSnowCoverageValue;	}	/** 	 * setter on hazeAccepted	 * 	 * @param _hazeAccepted (boolean): true if this parameter is available, false else	 */	public void setHazeAccepted(boolean _hazeAccepted) {		this.hazeAccepted = _hazeAccepted;	}	/** 	 * setter on sandWindAccepted	 * 	 * @param _sandWindAccepted (boolean): true if this parameter is available, false else	 */	public void setSandWindAccepted(boolean _sandWindAccepted) {		this.sandWindAccepted = _sandWindAccepted;	}} // class