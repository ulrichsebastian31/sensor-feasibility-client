package com.astrium.faceo.client.bean.programming.sps2.responses;/* * @(#)Sps2GridCellBean.java	 1.0  21/05/2010 * * * PROJET       : SITE FACEO * * LANGUAGE     : Java * * DESCRIPTION  : Cette classe est un conteneur d'informations pour les r&eacute;sultats  * de l'op&eacute;ration 'GetFeasibility' * * CREATION : * --------------------------------------------------------------------- * | Date       | Version | Description                                | * --------------------------------------------------------------------- * | 21/05/2010 |    1.0  |                                            | * --------------------------------------------------------------------- * * MODIFICATION : * --------------------------------------------------------------------- * | Date       | Version | Description                                | * --------------------------------------------------------------------- * |            |         |                                            | * --------------------------------------------------------------------- * */// importimport java.io.Serializable;import java.util.HashMap;import java.util.Map;/** * <B>SITE FACEO</B> <BR> *  * <P> * Cette classe est un conteneur d'informations pour les r&eacute;sultats * de l'op&eacute;ration 'GetFeasibility' * </P> * </P> *  * @author  GR * @version 1.0, le 21/05/2010 */public class GridCellBean implements Serializable {	/**	 * 	 */	private static final long serialVersionUID = 995689285131744522L;	/** id */	private String id = null;	/** status :	 * 	 * State of coverage of this cell. 	 * Descriptions of status codes are given in the table below. 	 * The value shall be ‘POTENTIAL’ in the case of a feasibility study, 	 * unless the cell cannot be covered at all in which case the status shall be ‘REJECTED’.	 * 	 * codes : "POTENTIAL", "PLANNED", "VALIDATED", "CANCELLED", "REJECTED", "ACQUIRED", "FAILED"	 * 	 * POTENTIAL :	 * Cells are marked as potential when they are estimated in the context of a feasibility study.	 * PLANNED :	 * At least one segment covering the cell has been planned. 	 * This state shall be used when the first attempt to cover the cell is planned 	 * or when additional attempts are planned after previous ones have failed 	 * (i.e. previous image segments covering the cell did not pass the validation criteria such as cloud cover). 	 * The nextAttemptDate shall be the forecasted acquisition date of the planned attempt 	 * and the lastAttemptDate shall be the date of the previous (usually unsuccessful) attempt.	 * 	 * VALIDATED :	 * The last acquired segment covering the cell has been validated. 	 * This is usually a final state meaning that an acceptable image has been obtained 	 * and that no more acquisition attempts need to be made to cover the cell.	 * 	 * CANCELLED :	 * The cell has been cancelled by the client. No more acquisition attempts will be made to cover it 	 * so the nextAttemptDate field shall be omitted and the remainingAttempts field shall be 0.	 * 	 * REJECTED :	 * The cell has been rejected by the programming system because it cannot be covered at all 	 * before the end of the requested period. No more acquisition attempts can possibly cover it 	 * so the nextAttemptDate field shall be omitted and the remainingAttempts field shall be 0.	 * 	 * ACQUIRED :	 * Not used in grid cells.	 * 	 * FAILED :	 * Not used in grid cells.	 * 	 */	private String status = null;	/** success Rate :	 * 	 * Probability that this cell will be covered by an acceptable image 	 * (i.e. depending on validation criteria) before the end of the requested period.	 */	private float successRate = -1;	/** estimated Success Date :	 * 	 * The estimated worst acquisition date (i.e. latest date at which the cell should be covered and validated). 	 * This value should be re-estimated in case the programming is delayed.	 */	private String estimatedSuccessDate = null;	/** last Attempt Date :	 * 	 * The date and time of the last acquisition attempt to cover this cell whether it was successful or not. 	 * This shall be omitted in the case of a feasibility study.	 */	private String lastAttemptDate = null;	/** next Attempt Date :	 * 	 * The date and time of the next acquisition attempt that can possibly be used to cover this cell. 	 * In the case of a feasibility study, this can be set to the time of the first possible attempt. 	 * It should be updated every time the status changes 	 * and usually omitted as soon as the cell state changes to ‘VALIDATED’.	 */	private String nextAttemptDate = null;	/** remaining Attempts :	 * 	 * Number of remaining possible acquisition attempts within the requested period that allow covering the cell. 	 * In the case of a feasibility study this is the total number of attempts that are possible within the requested period. 	 * It is usually omitted as soon as the cell state changes to ‘VALIDATED’.	 */	private int remainingAttempts = -1;		/**	 * polygon : the 5 points of the rectangle	 * 	 * Ground footprint of the cell. 	 * The GML polygon shall be expressed in the EPSG 4326 reference system.	 */	private Map<Integer, PointBean> points = 		new HashMap<Integer, PointBean>();		/**	 * d&eacute;but des m&eacute;thodes	 	 * 	 * Constructeur par d&eacute;faut : vide : convention Bean	 */	/**	 * Default Constructor. The Default Constructor's explicit declaration	 * is required for a serializable class. (GWT)	*/	public GridCellBean() {	}	/** ----------------------- getters ----------------------- */	/** 	 * getter on id	 * 	 * @return String : identifier	 */	public String getId() {		return (this.id != null) ? this.id : "";	}	/** 	 * getter on status	 * 	 * @return String : status	 */	public String getStatus() {		return (this.status != null) ? this.status : "";	}		/** 	 * getter on successRate	 * 	 * @return float : success Rate	 */	public float getSuccessRate() {		return this.successRate;	}	/** 	 * getter on estimatedSuccessDate	 * 	 * @return float : estimated Success Date	 */	public String getEstimatedSuccessDate() {		return (this.estimatedSuccessDate != null) ? this.estimatedSuccessDate : "";	}	/** 	 * getter on lastAttemptDate	 * 	 * @return float : last Attempt Date	 */	public String getLastAttemptDate() {		return (this.lastAttemptDate != null) ? this.lastAttemptDate : "";	}	/** 	 * getter on nextAttemptDate	 * 	 * @return float : next Attempt Date	 */	public String getNextAttemptDate() {		return (this.nextAttemptDate != null) ? this.nextAttemptDate : "";	}	/** 	 * getter on remainingAttempts	 * 	 * @return int : remaining Attempts	 */	public int getRemainingAttempts() {		return this.remainingAttempts;	}	/**	 * M&eacute;thode retournant la HashMap des points composant le segment	 *  	 * @return Map<Integer, Sps2PointBean>	: la HashMap	 */	public Map<Integer, PointBean> getPoints() {		return this.points;	}	/** ----------------------- setters ----------------------- */	/** 	 * setter on id	 * 	 * @param _id (String) : identifier value	 */	public void setId(String _id) {		this.id = _id;	}		/** 	 * setter on status	 * 	 * @param _status (String) : status value	 */	public void setStatus(String _status) {		this.status = _status;	}	/** 	 * setter on successRate	 * 	 * @param _successRate (float) : success Rate value	 */	public void setSuccessRate(float _successRate) {		this.successRate = _successRate;	}	/** 	 * setter on estimatedSuccessDate	 * 	 * @param _estimatedSuccessDate (String) : estimated Success Date value	 */	public void setEstimatedSuccessDate(String _estimatedSuccessDate) {		this.estimatedSuccessDate = _estimatedSuccessDate;	}	/** 	 * setter on lastAttemptDate	 * 	 * @param _lastAttemptDate (String) : last Attempt Date value	 */	public void setLastAttemptDate(String _lastAttemptDate) {		this.lastAttemptDate = _lastAttemptDate;	}	/** 	 * setter on nextAttemptDate	 * 	 * @param _nextAttemptDate (String) : next Attempt Date value	 */	public void setNextAttemptDate(String _nextAttemptDate) {		this.nextAttemptDate = _nextAttemptDate;	}	/** 	 * setter on remainingAttempts	 * 	 * @param _remainingAttempts (int) : remaining Attempts value	 */	public void setRemainingAttempts(int _remainingAttempts) {		this.remainingAttempts = _remainingAttempts;	}	/**	 * M&eacute;thode permettant la mise &agrave; jour de la HashMap	 * des points composant un segment	 * 	 * @param _points (Map<Integer, Sps2PointBean>)	: points's HashMap	 */	public void setPoints(			Map<Integer, PointBean> _points) {		this.points = _points;	}	}  // class